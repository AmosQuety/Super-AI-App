// ============================================
// PROPOSED FILE STRUCTURE
// ============================================

/**
 * src/
 * ‚îú‚îÄ‚îÄ index.ts                          # Entry point (minimal - just starts server)
 * ‚îú‚îÄ‚îÄ server.ts                         # Server class/factory
 * ‚îú‚îÄ‚îÄ config/
 * ‚îÇ   ‚îú‚îÄ‚îÄ index.ts                      # Export all configs
 * ‚îÇ   ‚îú‚îÄ‚îÄ app.config.ts                 # App-level config (PORT, ENV, etc.)
 * ‚îÇ   ‚îú‚îÄ‚îÄ cors.config.ts                # CORS configuration
 * ‚îÇ   ‚îú‚îÄ‚îÄ upload.config.ts              # File upload settings
 * ‚îÇ   ‚îî‚îÄ‚îÄ apollo.config.ts              # Apollo Server config
 * ‚îú‚îÄ‚îÄ middleware/
 * ‚îÇ   ‚îú‚îÄ‚îÄ index.ts                      # Export all middleware
 * ‚îÇ   ‚îú‚îÄ‚îÄ logging.ts                    # Already exists
 * ‚îÇ   ‚îú‚îÄ‚îÄ security.ts                   # Rate limiting, CORS setup
 * ‚îÇ   ‚îî‚îÄ‚îÄ error-handler.ts              # Global error handling
 * ‚îú‚îÄ‚îÄ routes/
 * ‚îÇ   ‚îú‚îÄ‚îÄ index.ts                      # Route aggregator
 * ‚îÇ   ‚îú‚îÄ‚îÄ health.routes.ts              # Health check routes
 * ‚îÇ   ‚îî‚îÄ‚îÄ info.routes.ts                # Info/status routes
 * ‚îú‚îÄ‚îÄ graphql/
 * ‚îÇ   ‚îú‚îÄ‚îÄ apollo-server.ts              # Apollo Server setup
 * ‚îÇ   ‚îî‚îÄ‚îÄ websocket-server.ts           # WebSocket/subscription setup
 * ‚îî‚îÄ‚îÄ utils/
 *     ‚îú‚îÄ‚îÄ shutdown.ts                   # Graceful shutdown handler
 *     ‚îî‚îÄ‚îÄ validators.ts                 # Startup validators
 */

// ============================================
// FILE 1: src/config/app.config.ts
// ============================================
export const AppConfig = {
  port: parseInt(process.env.PORT || '4001', 10),
  nodeEnv: process.env.NODE_ENV || 'development',
  isDevelopment: process.env.NODE_ENV !== 'production',
  isProduction: process.env.NODE_ENV === 'production',
} as const;

// ============================================
// FILE 2: src/config/cors.config.ts
// ============================================
import { CorsOptions } from 'cors';

export const corsConfig: CorsOptions = {
  origin: [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://localhost:8081",
    "exp://localhost:8081",
  ],
  credentials: true,
  methods: ["GET", "POST", "OPTIONS", "PUT", "DELETE"],
  allowedHeaders: [
    "Content-Type",
    "Authorization",
    "Apollo-Require-Preflight",
  ],
};

// ============================================
// FILE 3: src/config/upload.config.ts
// ============================================
export const uploadConfig = {
  maxFileSize: 10000000, // 10MB
  maxFiles: 10,
} as const;

// ============================================
// FILE 4: src/config/index.ts
// ============================================
export { AppConfig } from './app.config';
export { corsConfig } from './cors.config';
export { uploadConfig } from './upload.config';

// ============================================
// FILE 5: src/routes/health.routes.ts
// ============================================
import { Router, Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AppConfig } from '../config';
import { logger } from '../utils/logger';

export function createHealthRoutes(prisma: PrismaClient): Router {
  const router = Router();

  router.get('/health', async (_req: Request, res: Response) => {
    try {
      await prisma.$queryRaw`SELECT 1`;
      
      res.json({ 
        status: "OK", 
        timestamp: new Date().toISOString(),
        services: {
          database: "healthy",
          security: "configured"
        },
        environment: AppConfig.nodeEnv
      });
    } catch (error) {
      logger.error('Health check failed', { error });
      res.status(503).json({ 
        status: "ERROR", 
        timestamp: new Date().toISOString(),
        error: "Service unavailable" 
      });
    }
  });

  router.get('/', (_req: Request, res: Response) => {
    res.json({
      message: "GraphQL Server is running",
      version: "1.0.0",
      environment: AppConfig.nodeEnv,
      graphql: `http://localhost:${AppConfig.port}/graphql`,
      subscriptions: `ws://localhost:${AppConfig.port}/graphql`,
      health: `http://localhost:${AppConfig.port}/health`
    });
  });

  return router;
}

// ============================================
// FILE 6: src/graphql/apollo-server.ts
// ============================================
import { ApolloServer } from 'apollo-server-express';
import { GraphQLSchema } from 'graphql';
import { createContext } from '../resolvers/types/context';
import { queryComplexityPlugin } from '../utils/queryComplexityPlugin';
import { logger } from '../utils/logger';
import { AppConfig } from '../config';

export function createApolloServer(schema: GraphQLSchema): ApolloServer {
  return new ApolloServer({
    schema,
    context: createContext,
    csrfPrevention: true,
    introspection: AppConfig.isDevelopment,
    cache: 'bounded',
    plugins: [
      queryComplexityPlugin,
      {
        async serverWillStart() {
          logger.info('Apollo Server starting...');
          return {
            async drainServer() {
              logger.info('Draining Apollo Server...');
            }
          };
        }
      }
    ],
    formatError: (error) => {
      logger.error('GraphQL Error', { error });
      
      if (AppConfig.isProduction && !error.extensions?.code) {
        return new Error('Internal server error');
      }
      
      return error;
    }
  });
}

// ============================================
// FILE 7: src/graphql/websocket-server.ts
// ============================================
import { Server as HTTPServer } from 'http';
import { WebSocketServer } from 'ws';
import { useServer } from 'graphql-ws/lib/use/ws';
import { GraphQLSchema } from 'graphql';
import { createContext } from '../resolvers/types/context';
import { logger } from '../utils/logger';

export function createWebSocketServer(
  httpServer: HTTPServer,
  schema: GraphQLSchema
) {
  const wsServer = new WebSocketServer({
    server: httpServer,
    path: '/graphql',
  });

  const subscriptionServer = useServer(
    {
      schema,
      context: async (ctx) => createContext({ connection: ctx }),
      onConnect: () => {
        logger.info('üîå WebSocket client connected');
      },
      onDisconnect: (_ctx: any, code?: number, reason?: string) => {
        logger.info('üîå WebSocket client disconnected', { code, reason });
      },
    },
    wsServer
  );

  return subscriptionServer;
}

// ============================================
// FILE 8: src/utils/shutdown.ts
// ============================================
import { ApolloServer } from 'apollo-server-express';
import { Server as HTTPServer } from 'http';
import { PrismaClient } from '@prisma/client';
import { disconnectPrisma } from '../resolvers/types/context';
import { logger } from './logger';

export interface ShutdownHandlers {
  httpServer: HTTPServer;
  apolloServer: ApolloServer;
  subscriptionServer: any;
  prisma: PrismaClient;
}

export function setupGracefulShutdown(handlers: ShutdownHandlers) {
  const shutdown = async (signal: string) => {
    logger.info(`\nüõë Received ${signal}. Shutting down gracefully...`);
    
    handlers.httpServer.close(async () => {
      logger.info('‚úÖ HTTP server closed');
    });

    try {
      if (handlers.subscriptionServer) {
        handlers.subscriptionServer.dispose();
        logger.info('‚úÖ WebSocket subscriptions closed');
      }

      if (handlers.apolloServer) {
        await handlers.apolloServer.stop();
        logger.info('‚úÖ Apollo Server stopped');
      }

      await disconnectPrisma();
      logger.info('‚úÖ Shared Prisma client disconnected');

      await handlers.prisma.$disconnect();
      logger.info('‚úÖ Health check Prisma client disconnected');

      logger.info('‚úÖ Graceful shutdown completed');
      process.exit(0);
    } catch (error) {
      logger.error('‚ùå Error during shutdown:', { error });
      process.exit(1);
    }
  };

  process.on('SIGINT', () => shutdown('SIGINT'));
  process.on('SIGTERM', () => shutdown('SIGTERM'));
  
  process.on('unhandledRejection', (reason, promise) => {
    logger.error('Unhandled Rejection at:', { promise, reason });
  });

  process.on('uncaughtException', (error) => {
    logger.error('Uncaught Exception:', { error });
    shutdown('UNCAUGHT_EXCEPTION');
  });
}

// ============================================
// FILE 9: src/utils/validators.ts
// ============================================
import { SecurityConfig } from '../auth/security';
import { logger } from './logger';
import { AppConfig } from '../config';

export function validateSecurityConfig(): void {
  try {
    SecurityConfig.getJWTConfig();
    logger.info("‚úÖ Security configuration validated");
  } catch (error: any) {
    logger.error("‚ùå Security configuration error:", { error: error.message });
    if (AppConfig.isProduction) {
      throw error;
    }
  }
}

// ============================================
// FILE 10: src/middleware/security.ts
// ============================================
import { Application } from 'express';
import cors from 'cors';
import { corsConfig } from '../config';
import { RateLimitService } from '../auth/rate-limiting';

export function setupSecurity(app: Application): void {
  // CORS
  app.options('*', cors(corsConfig));
  app.use(cors(corsConfig));

  // Rate limiting
  RateLimitService.initializeRedis();
  app.use('/graphql', RateLimitService.getGraphQLLimiter());
  app.use('/auth/*', RateLimitService.getAuthLimiter());
  app.use('/health', RateLimitService.getGeneralLimiter());
}

// ============================================
// FILE 11: src/server.ts (Main server class)
// ============================================
import express, { Application } from 'express';
import { createServer, Server as HTTPServer } from 'http';
import { PrismaClient } from '@prisma/client';
import { ApolloServer } from 'apollo-server-express';
import { graphqlUploadExpress } from 'graphql-upload-minimal';
import { makeExecutableSchema } from '@graphql-tools/schema';

import { typeDefs } from './schema/schema';
import { resolvers } from './resolvers/index';
import { AppConfig, uploadConfig } from './config';
import { setupSecurity } from './middleware/security';
import { createHealthRoutes } from './routes/health.routes';
import { createApolloServer } from './graphql/apollo-server';
import { createWebSocketServer } from './graphql/websocket-server';
import { setupGracefulShutdown } from './utils/shutdown';
import { validateSecurityConfig } from './utils/validators';
import { logger } from './utils/logger';
import {
  loggingMiddleware,
  graphQLLoggingMiddleware,
  errorLoggingMiddleware,
  securityLoggingMiddleware,
  performanceMiddleware
} from './middleware/logging';

export class GraphQLServer {
  private app: Application;
  private httpServer: HTTPServer;
  private apolloServer: ApolloServer;
  private subscriptionServer: any;
  private prisma: PrismaClient;

  constructor() {
    this.app = express();
    this.prisma = new PrismaClient();
  }

  private setupMiddleware(): void {
    // Security
    setupSecurity(this.app);

    // Logging
    this.app.use(loggingMiddleware);
    this.app.use(graphQLLoggingMiddleware);
    this.app.use(securityLoggingMiddleware);
    this.app.use(performanceMiddleware);

    // Body parsing
    this.app.use(express.json());

    // File uploads
    this.app.use(graphqlUploadExpress(uploadConfig));

    // Error logging (should be last)
    this.app.use(errorLoggingMiddleware);
  }

  private setupRoutes(): void {
    const healthRoutes = createHealthRoutes(this.prisma);
    this.app.use(healthRoutes);
  }

  private async setupGraphQL(): Promise<void> {
    const schema = makeExecutableSchema({ typeDefs, resolvers });
    
    this.apolloServer = createApolloServer(schema);
    await this.apolloServer.start();

    this.apolloServer.applyMiddleware({
      app: this.app,
      path: '/graphql',
      cors: false,
    });

    this.httpServer = createServer(this.app);
    this.subscriptionServer = createWebSocketServer(this.httpServer, schema);
  }

  async start(): Promise<void> {
    try {
      // Validate configuration
      validateSecurityConfig();

      // Setup components
      this.setupMiddleware();
      this.setupRoutes();
      await this.setupGraphQL();

      // Start listening
      this.httpServer.listen(AppConfig.port, () => {
        logger.info(`
          üöÄ GraphQL Server ready at http://localhost:${AppConfig.port}${this.apolloServer.graphqlPath}
          üîå Subscriptions ready at ws://localhost:${AppConfig.port}/graphql
          üîç Apollo Sandbox available at http://localhost:${AppConfig.port}/graphql
          üè• Health check available at http://localhost:${AppConfig.port}/health
        `);
        
        logger.info(`
          üìä Services Initialized:
          ‚úÖ Database Service (Optimized with connection pooling)
          ‚úÖ Security Services
          ‚úÖ GraphQL Service
          ‚úÖ WebSocket Service
          ‚úÖ Singleton Services (Face Recognition, Gemini AI)
        `);
      });

      // Setup graceful shutdown
      setupGracefulShutdown({
        httpServer: this.httpServer,
        apolloServer: this.apolloServer,
        subscriptionServer: this.subscriptionServer,
        prisma: this.prisma,
      });

    } catch (error) {
      logger.error('Error starting server:', { error });
      throw error;
    }
  }
}

// ============================================
// FILE 12: src/index.ts (NEW - Super clean!)
// ============================================
import * as dotenv from 'dotenv';
import { GraphQLServer } from './server';
import { logger } from './utils/logger';

// Initialize environment
dotenv.config();

// Start server
const server = new GraphQLServer();

server.start().catch((error) => {
  logger.error('Failed to start server:', { error });
  process.exit(1);
});
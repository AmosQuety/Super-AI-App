// src/resolvers/mutations/geminiMutations.ts
import { AppContext } from "../types/context";
import { SafeIntelligentMatcher } from "../../IntelligentMatcher/safety/SafeIntelligentMatcher";
import customResponses from "../../IntelligentMatcher/customResponses";

const intelligentMatcher = new SafeIntelligentMatcher(customResponses);

export const geminiMutations = {
  generateGeminiContent: async (
    _: any,
    { prompt }: { prompt: string },
    context: AppContext
  ) => {
    console.log("Received prompt:", prompt);

    if (!prompt || prompt.trim().length === 0) {
      return {
        generatedText: "",
        success: false,
        message: "Prompt cannot be empty",
      };
    }

    const cleanPrompt = prompt.trim().substring(0, 1000);

    try {
      // Try intelligent matcher first
      try {
        const matchResult = await intelligentMatcher.findBestMatch(cleanPrompt);
        if (matchResult.match && matchResult.confidence >= 0.7) {
          return {
            generatedText: matchResult.suggestedResponse || "I'm here to help!",
            success: true,
            message: "Custom response provided.",
          };
        }
      } catch (matcherError) {
        console.log("IntelligentMatcher error, proceeding to Gemini API:", matcherError);
      }

      // Use Gemini AI service
      const generatedText = await context.geminiAIService.generateContent(cleanPrompt);
      
      return {
        generatedText,
        success: true,
        message: "Response generated by Gemini AI",
      };
    } catch (error: any) {
      console.error("Error in generateGeminiContent:", error);
      return {
        generatedText: "",
        success: false,
        message: `Error: ${error.message || "Failed to generate content."}`,
      };
    }
  },
};